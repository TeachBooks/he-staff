# .github/workflows/book-post-deploy.yml (Updated - Pass ID via env var)
name: Book Post-Deployment (Updated)

# on:
#   workflow_run:
#     workflows: ["call-deploy-book"] # Triggered after the main build workflow completes
#     types:
#       - completed

jobs:
  copy-to-server:
    runs-on: self-hosted # Runs on your server (e.g., he01)
    if: ${{ github.event.workflow_run.conclusion == 'success' }} # Only run if the build workflow succeeded
    steps:
      # Step 1: Get workflow details (Branch Name) - MINIMAL DEBUGGING STEP
      - name: Get workflow details (Branch Name) - MINIMAL DEBUGGING STEP
        id: workflow-details
        uses: actions/github-script@v6
        with:
          script: |
            console.log('Minimal script test execution.');
            // Try setting a simple static output
            core.setOutput('branch', 'static-debug-branch');
            console.log('Minimal script test finished.');

      # Step 2: Download book artifact
      - name: Download book artifact
        id: download-artifact
        uses: actions/github-script@v6
        # Pass workflow run ID as an environment variable
        env:
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            // Access the ID from the environment variable
            const workflow_run_id = process.env.WORKFLOW_RUN_ID;
            console.log(`Workflow Run ID: ${workflow_run_id}`);
            if (!workflow_run_id) {
              core.setFailed('Workflow Run ID environment variable not set!');
              return;
            }
            const artifact_path = '/tmp/book_artifact'; // Define download path
            fs.mkdirSync(artifact_path, { recursive: true });
            console.log(`Created artifact directory: ${artifact_path}`);
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: parseInt(workflow_run_id, 10) // Ensure it's an integer
            });
            const book_artifact = artifacts.data.artifacts.find(a => a.name === 'main');
            if (!book_artifact) {
              core.setFailed('No artifact named "main" found!');
              return;
            }
            console.log(`Found artifact: ${book_artifact.name} (ID: ${book_artifact.id})`);
            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: book_artifact.id,
              archive_format: 'zip'
            });
            const zip_path = path.join(artifact_path, 'book.zip');
            fs.writeFileSync(zip_path, Buffer.from(download.data));
            console.log(`Artifact downloaded to ${zip_path}`);
            core.setOutput('artifact_zip_path', zip_path);

      # Step 3: Deploy book using deployment script
      - name: Deploy book using deployment script
        run: | # Use literal block scalar
          # Access outputs directly using standard syntax
          BRANCH='${{ steps.workflow-details.outputs.branch }}'
          ARTIFACT_ZIP_PATH='${{ steps.download-artifact.outputs.artifact_zip_path }}'

          # Basic check if variables are empty
          if [ -z "$BRANCH" ] || [ -z "$ARTIFACT_ZIP_PATH" ]; then
            echo "::error::Branch name or Artifact path is empty. Previous steps might have failed."
            exit 1
          fi

          echo "Deploying book for branch: $BRANCH"
          echo "Artifact zip path: $ARTIFACT_ZIP_PATH"

          # Define directory for extracting the artifact content
          EXTRACT_DIR="/tmp/book-extract-$$" # Use process ID for uniqueness
          mkdir -p "$EXTRACT_DIR"
          echo "Created extraction directory: $EXTRACT_DIR"

          # Extract the downloaded zip file
          echo "Extracting artifact from $ARTIFACT_ZIP_PATH to $EXTRACT_DIR..."
          unzip -q "$ARTIFACT_ZIP_PATH" -d "$EXTRACT_DIR"
          if [ $? -ne 0 ]; then
            echo "::error::Failed to unzip artifact."
            exit 1
          fi
          echo "Artifact extracted successfully."

          # List extracted files for verification (optional)
          echo "Extracted content:"
          ls -la "$EXTRACT_DIR"

          # *** Call the updated deploy-book.sh script ***
          echo "Running deployment script: /var/web_server/deploy-book.sh $BRANCH"
          sudo /var/web_server/deploy-book.sh "$BRANCH" # Pass branch name as argument
          if [ $? -ne 0 ]; then
            echo "::error::Deployment script failed."
            # Optionally keep temp files for debugging by commenting out the exit
            # exit 1
          else
            echo "Deployment script finished successfully."
          fi

          # Clean up temporary files
          echo "Cleaning up temporary files..."
          rm -rf "$EXTRACT_DIR"
          rm -f "$ARTIFACT_ZIP_PATH" # Remove the zip file itself
          # Remove the parent artifact directory if empty (be cautious)
          rmdir /tmp/book_artifact 2>/dev/null || true

      # Step 4: Update branch index (Optional - Call Script)
      - name: Update branch index (Optional - Call Script)
        # Executes the separate script to generate the index HTML file.
        run: |
          echo "Calling update-branch-index.sh script..."
          # Call the script that now contains the correct logic and paths
          sudo /var/web_server/update-branch-index.sh
          if [ $? -ne 0 ]; then
            echo "::error::Failed to update branch index."
            # exit 1 # Optionally fail the workflow
          else
            echo "Branch index script finished."
          fi